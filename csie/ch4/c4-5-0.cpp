/*
有一個水壩的牆受到地震的影響受損了。事情緊急，必須馬上派人去修，以免水淹之患。
修護任務非常困難，還好現在有 n 個志願者。 政府製作了編號 1∼n,總共n個號碼牌。
每個志願者在去修理之前，會發給他一個號碼牌。 任務結束後，志願者把他的號碼牌交還回來。
現在水壩安全了，但不幸的是並不是每個志願者都有回來。有些志願者壯烈的犧牲了。
你的任務是根據交還回來的號碼牌，找出有哪些號碼牌的志願者犧牲了。
Input:
輸入含有多筆測資。 每筆測資2列，第一列有2個整數 n，R。
（1 <= R <= n <= 10000）n代表共有多少個志願者，R代表有回來的志願者數目。
接下來的一列有R個整數，代表有回來的志願者的號碼牌。
Output:
對每筆測資輸出一列。輸出犧牲者的號碼牌，由小到大排列。請注意，每個號碼的後面都有一個空格（最後一個後面也有）。
如果每個志願者都有回來，請輸出單獨的一個 *
Sample Input:
5 3
3 1 5
6 6
2 3 5 4 1 6
Sample Output:
2 4
*
*/

// 解答
#include <iostream>
using namespace std;

int main()
{
    int n, R;
    int i, man;
    int back[1005];

    while(cin >> n >> R)
    {
        // 先將back生還陣列清0
        i = 1;
        while(i <= n)
        {
            back[i] = 0;
            i += 1;
        }

        // 把生還者的陣列位置，數量改成1
        i = 0;
        while(i < R)
        {
            cin >> man;
            back[man] = 1;
            i += 1;
        }

        // 如果n = R，全員生還，則輸出*
        if(n == R)
        {
            cout << '*' << endl;
        }
        // 否則輸出犧牲者的號碼(等於0的陣列位置)
        else
        {
            i = 1;
            while(i <= n)
            {
                if(back[i] == 0)
                {
                    cout << i << ' ';
                }
                i += 1;
            }
            cout << endl;
        }
    }

    return 0;
}